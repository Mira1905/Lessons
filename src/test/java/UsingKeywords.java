import org.testng.annotations.Test;

import java.util.ArrayList;
import java.util.List;

public class UsingKeywords {
      /*
Class — это, по сути, шаблон для объекта. Он определяет, как объект будет выглядеть и какими функциями обладать.
Каждый объект является объектом какого-то класса.
    */

//**********************************************************************************************************************

 /* Используя оператор break, можно вызвать немедленное завершение цикла, пропуская условное выражение и любой остальной
 код в теле цикла.*/

    @Test
    public void test() {

        for (int i = 0; i < 100; i++) {
            if (i == 10) break;
        }
    }

    //**********************************************************************************************************************
/*boolean
true(правда) false(ложь)
с помощью if-else прописали, что при a>5, необходимо в консоль выводить true, а во всех остальных случаях -
выводить false.
циклы while и for
условные операторы if-else
более пяти*/
    static boolean moreThanFive(int a) {
        if (a > 5) {
            return true;
        } else {
            return false;
        }
    }

    public static void main(String[] args) {
        System.out.println(moreThanFive(7));
    }

    /* далее вызвали метод moreThanFive()
       и по сколько 7>5, в консоли мы увидели слово true.
    Синтаксис оператора if..else
    if(Логическое выражение)
    {
       //Выполняется, если истинно
    } else{
       //Выполняется, если ложно
    }
       */
    @Test
    public void tes1() {

        int x = 30;

        if (x < 20) {
            System.out.print("Это оператор if");
        } else {
            System.out.print("Это оператор else");
        }
    }


//**********************************************************************************************************************

/*1. case - Это оператор ветви. Он позволяет идентифицировать ветви выполнения в операторе switch. Ветвь кода
идентифицируется значением выражения.
2. switch прописываем выражение для сравнения
3. Выражение в switch должно иметь тип char, byte, short, int, enum  или String. Использование любого другого типа,
например float, приведет к ошибке компиляции.
4. Оператор switch может только проверять на равенство. Такие операторы как >=, <= недопустимы.
5. Если уберем break;  программа выполнит все case после первого совпадения и до конца блока switch. */


    public static List<String> getPlanetAtmosphere(int seqNumberFromSun) {
        List<String> result = new ArrayList<>(); //создаем объект ArrayList
        switch (seqNumberFromSun) {
            case 1:
                result.add("Нет атмосферы");
                break;
            case 2:
                break;
            case 4:
                result.add("Углекислый газ");
                break;
            case 3:
                result.add("Углекислый газ");
                result.add("Азот");
                result.add("Кислород");
                break;
            case 5:
            case 6:
                result.add("Водород");
                result.add("Гелий");
                break;
            case 7:
            case 8:
                result.add("Метан");
                result.add("Водород");
                result.add("Гелий");
                break;
            default:
                break;
        }
        return result;

    }

    /* вызываем метод с любым параметром   */
    @Test
    public void planet() {
        System.out.println(getPlanetAtmosphere(3));
    }

//**********************************************************************************************************************
    /*
    Обработка исключений в Java основана на использовании в программе следующих ключевых слов:
try – определяет блок кода, в котором может произойти исключение;
catch – определяет блок кода, в котором происходит обработка исключения;
finally – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока try.
Эти ключевые слова используются для создания в программном коде специальных обрабатывающих конструкций: try{}catch, try{}catch{}finally, try{}finally{}.
throw – используется для возбуждения исключения;
throws – используется в сигнатуре методов для предупреждения, о том что метод может выбросить исключение.
1. finally - Оператор позволяет выполнить код, после того, как try...catch, независимо от результата:
2. Опрераторы try и catch составляют единое целое.
   В операторе catch указывается тип исключения, которое он может обработать и название переменной исключения.
     */

    @Test
    public void tes2() {
        try {
            int[] myNumbers = {1, 2, 3};
            System.out.println(myNumbers[10]);
        } catch (Exception e) {
            System.out.println("Что-то не так.");
        } finally {
            System.out.println("Ошибка");
        }
    }


   /*
   Если возникает ошибка, мы можем использовать ее try...catch для ее обнаружения и выполнения кода для ее обработки
    */

    @Test
    public void tes3() {
        try {
            int[] myNumbers = {1, 2, 3};
            System.out.println(myNumbers[10]);
        } catch (Exception e) {
            System.out.println("Что-то не так.");

        }
    }
//**********************************************************************************************************************
/*
существуют ключевые слова, которые дают нам больше власти над циклом. Они позволяют нам:
завершить цикл раньше времени (оператор break)
проигнорировать часть кода (оператор continue)
- Continue позволяет опустить участок кода и вернуться в начало цикла.
- Оператор continue записывается так: continue;
 */

    @Test
    public void tes4() {

        for (int i = 1; i <= 7; i++) {
            System.out.println(i + ": я выполянюсь перед continue!");
            if (i > 2)
                continue;
            System.out.println("     " + i + ": я выполянюсь всего два раза ;(");
        }
    }
/*
1. видим цикл for, хочу чтобы первая строка выполнялась семь раз:
2. вторая строка всего два раза
3. перед вторым выводом в консоли пишем условие
4. по этому каждый раз когда i будет больше 2 (а именно будет равняться 3, 4, 5 , 6  и 7) вторая строка не будет
выведена в консоль. Это будет происходить потому, что continue будет перенаправлять нас в начало цикла:
 */

//**********************************************************************************************************************
/*
 do {
        // тело цикла
    } while (условие);
    При каждом выполнении цикла do-while сначала выполняется тело цикла, а затем вычисляется условное выражение.
 */
    @Test
    public void tes5() {

        int i = 1;
        do {
            System.out.println("i = " + i);
            i++;
        } while (i < 11);
    }
/*
вывод значений от 1 до 10
i+1 - возвращает значение i+1.
i++ - увеличивает значение i на 1, возвращает значение i до увеличения.
++i - увеличивает значение i на 1, возвращает новое значение i.
 */


//**********************************************************************************************************************
    /*
extends - это ключевое слово для наследования от определенного класса
implements - для реализации в классе интерфейса
     */
//**********************************************************************************************************************
/*
Суть модификатора final - сделать дальнейшее изменение объекта невозможным.
Можем применять этот модификатор тремя способами: для класса, для поля (переменной) и для метода.
Если мы хотим чтобы после инициализации никто не мог изменить вашу переменную, пишем слово "final":
*Обратите внимание: переменные с final - это константы. При этом их принято писать заглавными буквами
* - тут CamelStyle не работает :
 */

    @Test
    public void tes6() {

        final int I = 1;
        System.out.println(I);

    }
}
